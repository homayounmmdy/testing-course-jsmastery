# The Complete Next JS Testing Course

## What is the testing ?

Testing is how you make sure your code actually works.

it's safety net between you and production code.

by testing you make sure every feature works by your expected.

by well testing allow you to

- refactor don't break anything it will let you to refactor with confidence
- app become stable as it grow
- Catch bugs early
- Document behavior
- Deliver better UX

> You write code that test your code you do not check eg button manually

> Testing let you move fast without breaking things

## Different types of test

- Testing by Scope
  - Unit tests
  - Components tests
  - Integration tests
  - End-to-end tests
- Testing by Knowledge
  - Black box testing (testing by user perspective)
  - White box testing (testing under hood logic)
  - Gray box testing (balance between both perspective)
- Testing by Purpose
  - Functional testing
  - Non-Functional testing
- Testing by Execution
  - Manual testing
  - Automated testing

## Scope

It's about how much your system are you testing at once

## Unite Testing

it's like looking through the microscope you see the smallest testable part of application and
in Completely isolation. because you testing one piece without connection to anything else it's super fast

because this isolation it makes fast but also you have you muck several things because it's isolate.

it's best for

- Business logic
- Algorithms
- Data transformations
- any code that get input and produce predicted output

but they are less useful for testing:

- User interfaces
- Network communication
- Complex workflow

## Component Testing

a component is self contain pice of UI that combine

- logic
- presentation
- behavior

testing component is different from pure function

a component

- receive props
- manage state
- respond to user interactions
- render visual elements

## Integration Testing

the integration test is like how organize of body are works together. your testing the

- connection
- the hand shakes
- the data flow between parts of applications

some time you test two connection like user with database sometimes is chain of connections

## End to End Testing

it's mot comprehensive and realistic but also the most complex and expensive
when you run end to end you running real user journey for entire application using actual data.

It is same as real world. these test are slow because it's use :

- real browser automation
- network requests
- database operation
- external service call

## Testing Knowledge

it's about how much you know about the internal working of the system.
it's not only help about what test to write it's also help to predicted how bugs
you could catch.

## Black Box Testing

is about being customer using production without knowing about how it's made they only care that
it do what is suppose to do. it's only focus on input and output. like clicking add add to card that incess the
list of items.

It is valuable for

- Long-term maintenance
- Tracking the system

when testing without understanding code you find

- Confusing error messages
- Unexpected behavior
- Missing features

but you can't test console error , or putting code in input and stuff like that

## White Box Testing

now you have full Knowledge on

- Internal structure
- Logic
- Implementation of code

it's like engineer check that thing that they build. this test do

- Exercise specific code paths
- Test particular algorithms
- Verify that internal logic

you check what happen if user do something wrong or checking the edge cases.
because you know the logic you can write test that

- Hit every branch
- Test every condition
- Verify that each piece of code works as intended

it's valuable for testing

- Algorithms
- Data structures
- complex business logic

the challenge is that can tidy with Implementation because you test

- Internal methods
- Private functions
- Specific code paths

by refactoring you might just break some places even the external behavior be the same

it's mostly used for

- Mathematical calculations
- Data processing algorithms
- Security functions
- Core business logic

the things that often change

## Gray Box Testing

when you have some Knowledge of internal and external. you know what tool do you use
but still do not mainly focus on logic you check by user perspective while check that work same
as expected. by this you can

- Test the riskiest areas
- Use realistic test data
- Cover edge code paths

## Testing by purpose

Testing by purpose refers to categorizing software testing based on its specific goal or intent, such as ensuring correctness, reliability, performance, or security. Examples include functional testing (to verify features work as specified), regression testing (to ensure new changes donâ€™t break existing functionality), and usability testing (to evaluate user experience).

## Functional Testing

function do based on requirements e.g when user search for product dose product appear.
also functional has multiply parts like

### smoke testing

like turn one car and make sure the engin is start the lights work and the basic system operational
this are quick and high level tests that verify most basic functionality.
The first test after deploying the code

### sanity testing

it's more focused like checking specific system work like air conditioning still work after you make
some changes. sanity check the area you modify it's still do task correctly.
this test help to **catch regressions**

### regressions testing

the most important part of the functional testing . this test check that the new code do not break the previous
code accordantly. The challenge it become time consuming as the application growths.

### User Acceptance Testing (UAT)

the final validation before release this test not by

- Developers
- QA engineers
- Product team

it's show error and technical often forgot things like

- COnfusing workflows
- Missing features
- Performance problems
- Integration issues

## Non-Functional Testing

User not care it's works the user care more on :

- work well
- quickly
- securely
- reliably

### Performance Testing

this bing and contain several categories:

#### Performance Testing: Load testing

by this you check that platform can work on multiply user use it.

#### Performance Testing : Stress testing

gradually ingress the system until it crash you find the limits and how system behave on extreme condition
help to plan for traffic

#### Performance Testing Volume testing

focus especially or large amount of data. how application works when database contain minions of data. The search remain
fast

### Security Testing

this test include to checking

- Auth systems
- Validating input handling
- Verify data encryption
- Common vulnerabilities

### Usability testing

it's check how easy and pleasant you application is to use this include testing:

- Navigation & info architecture
- Evaluating form design
- Error handling
- Checking accessibility
- Verify that the app works

### Compatibility Testing

It's make sure the application is working correctly across different enticements.

## Testing by Execution

it's about How and When the test actually run. are you run manually when you fill like it or
you have Automated system the run every step of the system

### Manual Testing

It's like Monkey see Monkey do. Sometimes need human things like bad UI can't catch by
test it can get by user. it's like exploration also it's often called **Exploratory Testing**.

### Usability Testing

Instead of you testing app somebody else test and you watch along side of them. by this you

- Noticing where people hesitate
- What confuses them
- How they completely ignore

The cons are

- Manual testing takes time
- Doesn't scale well
- People miss things

you have balance between automate and manual

## Automated Testing

this when you handed the software tools that run test for you. the best part this

- Speed
- Consistency
- Scales like crazy

it's like saver for regression testing

## Testing Strategies

the problems is you don't know

- What to test
- How much to test
- When to test

the problem is that you sometimes do not test some cases you over test some places and
worse is get falsy truthy which is green while is not testing the right thing this
are pattern that helps that stop these.

- Testing Trophy
- Honeycomb Strategy
- Ice Cream Cone Anti-Pattern
- Testing Diamond
- Testing Pyramid

## Testing Pyramid

> Different types of tests have vastly different costs and benefits

[testing pyramid]('./images/testing_pyramid.png');

during developments you make some changes like :

- Refactor code
- Add feature
- Fix bug
- Update dependencies

It's for apps like

- Finance
- Science
- Complex algorithms

## Ice Cream Cone Anti-Pattern

[Ice Cream Cone Anti-Pattern]('./images/ice_cream_pattern.png');

This is the opposite of testing pyramid
also have some negative things like :

- Feedback becomes painfully slow
- Debugging becomes a nightmare
- Maintenance get out of hand

## Testing Trophy

[Ice Cream Cone Anti-Pattern]('./images/testing_trophy.png');

This is looks familiar to pyramid but with some difference

## Honeycomb Strategy

[Honeycomb Strategy]('./images/honeycomb_strategy.png');

build separate testing strategy for each part of application.

here is the example

[Honeycomb example]('./images/honeycomb_example.png');

> Core idea : test where i matters most

the problems are

- Service contracts
- Integration environments
- Data dependencies

## Diamond Testing

[testing diamond]('./images/testing_diamond.png');

the result of using this testing strategy is

- Comprehensive
- Practical

it't good when the project have

- some complex business logic
- some user interaction complexity

things like

- e-commerce
- sass dashboard
- CMS
- Finance
- health care

this systems are need

- slid logic validation
- strong integration checks
- few full end-to-end workflows

it's great when your app sit between simple and complex

> like any other testing strategy it's guide , not rule

- adopt it thoughtfully
- tailor it to your system
- always remember have perfect shape

## Choose the right strategy

Here is the things that you have to in mind before choosing any testing strategy

### Application Architecture

- for the data base system with complex logic go for testing pyramid
- for modern application with react and have lot's of external API go for testing trophy

Ask your self

> Is most of your complexity in business logic -> Invest in Unite tests

> Is it in integration or UI behavior ? -> priorities Integration tests

> Are there critical workflows that can't break ? -> focus End-to-End tests

### Team and Organization

even best strategy wouldn't stick if it doesn't fit your team or organization.

match the strategies on how your team built and ship the software for software that deploy
a lot focus on unite and integration for the teams that release not much go for end-to-end.

### Risk and Business Context

all bugs are not equal some break feature other beak entire business. In Finance a single mistake
cost money unite test matters most

if you build social or content driven apps UX is matters so Integration and UI test take priority.

think of it as risk and reward

> If calculation errors would be catastrophic -> Unit tests

> If integration points are fragile -> Integration tests

> If user workflows are critical -> End-to-end test

## Building your testing strategy

answer this questions to or building your own testing strategy based on answer

### 1. Assess Your Current State

- Which tests do you have right now ?
- How long do they take to run ?
- How often do they fail ?
- What kinds of bugs do they actually catch , and which ones lip through ?

### 2. Identify Your Constrains

- How much time can we realistically dedicate to testing ?
- How often do we deploy ?
- What's our tolerance for bugs ?
- What's our team's testing experience level ?

### 3. Define Your Goals

- Catch regressions before prod ? 
- Improve code quality ?
- Enable safe refactoring ? 
- Support continuous deployment ? 

### 4. Start Small and Iterate 

don't aim for perfect testing setup on day one it dose not exit pick one area that matters the most 

may it could be adding integration tests to critical APIs or few End-to-end for key user flows 

> Testing maturity comes from Iteration not a single revolution

### 5. Measure and Adjust 

testing is not about set and forgot and you have to measure it.

- Are our test catching bugs before users do  ? 
- Is our feedback loop fast enough ? 
- Do tests give us confidence to deploy anytime ? 

if the answer NO adjust and evolve the strategy

## testing tools 

### Assertion

this is the statement with expected output like 

Is this value equal to 5 ? 3 + 2 

if yes this success otherwise it's fails

### Test runner 

it's engine that execute the test 

- It find all your tests 
- Runs them in order
- Tells you which ones passed or failed

### Mocking 

create fake version of things for testing

### Test suite

a collection of rated test that group together. like organizing test into folders.

### Test fixture

prepare data that test used like having template that using multiply places.

### Coverage 

a measurement of how much of code is tested

## Unite Testing 

For the Unite testing mostly used by Jest and it's build by facebook but it has issue 
because it run all in it self and when test grow it's become hard for 

- Sandboxing
- Managing mocks

for things like this lighter test runner like  vite or mocha run test faster because they have 

- less initialization overhead
- simpler test environments

the vite has 

- works well with ES modules 
- Integrates smoothly with Vite 
- Has a Jest-compatible API 

the down side is 

- Fewer resources 
- less community example

## Frontend Testing Tools 

it's dealing with 
- user interactions
- visual elements 
- browser environments 

we have react-testing-library that test only what user see and do  
and find same as user by 
- text 
- labels 
- roles

it's about testing user behavior not the Implementation details 

for browser the mostly use JSDOM that simulate separate place for testing.

## Backend Testing 
the is about 

- APIs handle data
- Implement business rules 
- Manage security 
- Handle complex operation

you need tools to 

- Make HTTP requests 
- Validate responses
- Mock external services 
- Verify server-side code 

the most important are 

### 1: API Tools 

if use nodejs Supertest is good fit for it. by this you can test 
- Routes 
- Middleware 
- Response handling

for things that full feature Axios better and it is run everywhere 
for simpler and lighter you can use NodeFetch where it's shorter but give 
less functionality and it is work same as fetch in javascript  

### 2: Database tools 

we have in memory that store the data in the RAM it is come on RAM and when the 
test finished it will vanished 

the benefits are 

- You get Speed 
- Your database is isolated 
- You have Simplicity 
- You save Resources 

for exact real scenarios you can use docker testing the benefits of these are 

- Database-Specific Features 
- Production Parity 
- Integration Testing 
- CI/CD Reliability 
- Complex dependencies

## End-to-End Testing Tools 

This when you test the entire system as user and backend. you not simulate you 
test with real tools.

### Playwright

It's control real browser chrome , firefox , safari to simulate user interaction.
it can 

- Click buttons 
- Fill forms 
- Navigate between pages 
- Verify that everything works 

and It's maintained by Microsoft

### Cypress 

It's only support firefox and chrome based browsers. and has problem with multiply 
tabs and domains. It's fantastic for straight forward single domain work flows. It can't test 

- OAuth logins 
- Integrations across multiple subdomains 

and easy to use and it's visible during testing.

### Selenium

Before all this. It is been for decade ago. Compare to new tools selenium is 

- Slower
- Harder to set up 
- More boilerplate code 

debugging is nightmare because it's rely on old webDriver.

For new project good to use Playwright but if you consider DX and debugging tools go
for Cypress but be aware for it browser limitation

## Common Misunderstanding

If jest , vitest if for unite can we use if for integration or e2e ?

They are test runner their job is find test run test and show result. they 
don't care what test you write  as long as it's javascript and follow the right 
structure they all good.

For other types of testing you just expand your testing you can't write technically
E2E with jest but it's not build for that by doing this you invent the wheel all the time
you have use external tools or sometimes build your own 

## Introduction to Unite testing

It's testing each piece separate in different environments and it's fast and focused.
Every unite test follow Arrange-Act-Assert it's provide clarity and Consistency make it easier to 
- read 
- write 
- maintained

### Arrange 

Set up everything for the test it's include 
- input data for the function 
- many mock objects 
- initial state that your code relay on 

like this example blew 

```javascript
const userData = {name : "John Doe", email : "john@example.com",age : 25}
const mockNotificationServer = {sendEmail: jest.fn()}
const userValidator = new userValidator();

```

### Act 

- perform the specific action that being tested usually single line of code 

```javascript
const validationResult = userValidator.validateUser(userData)
```

### Assert 

verify that the behavior do the expected result 

```javascript
expect(validationResult.isValid).toBe(true);
expect(validationResult.errors).toHaveLength(0);
expect(mockNotificationServer.sendEmail).toHaveBeenCalledWith(userData.email);
```

here is the full example 

```javascript
// Arrange
const userData = {name : "John Doe", email : "john@example.com",age : 25}
const mockNotificationServer = {sendEmail: jest.fn()}
const userValidator = new userValidator();


// Act 
const validationResult = userValidator.validateUser(userData)


// Assert
expect(validationResult.isValid).toBe(true);
expect(validationResult.errors).toHaveLength(0);
expect(mockNotificationServer.sendEmail).toHaveBeenCalledWith(userData.email);
```

