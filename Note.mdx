# The Complete Next JS Testing Course

## What is the testing ?

Testing is how you make sure your code actually works.

it's safety net between you and production code.

by testing you make sure every feature works by your expected.

by well testing allow you to

- refactor don't break anything it will let you to refactor with confidence
- app become stable as it grow
- Catch bugs early
- Document behavior
- Deliver better UX

> You write code that test your code you do not check eg button manually

> Testing let you move fast without breaking things

## Different types of test

- Testing by Scope
  - Unit tests
  - Components tests
  - Integration tests
  - End-to-end tests
- Testing by Knowledge
  - Black box testing (testing by user perspective)
  - White box testing (testing under hood logic)
  - Gray box testing (balance between both perspective)
- Testing by Purpose
  - Functional testing
  - Non-Functional testing
- Testing by Execution
  - Manual testing
  - Automated testing

## Scope

It's about how much your system are you testing at once

## Unite Testing

it's like looking through the microscope you see the smallest testable part of application and
in Completely isolation. because you testing one piece without connection to anything else it's super fast

because this isolation it makes fast but also you have you muck several things because it's isolate.

it's best for

- Business logic
- Algorithms
- Data transformations
- any code that get input and produce predicted output

but they are less useful for testing:

- User interfaces
- Network communication
- Complex workflow

## Component Testing

a component is self contain pice of UI that combine

- logic
- presentation
- behavior

testing component is different from pure function

a component

- receive props
- manage state
- respond to user interactions
- render visual elements

## Integration Testing

the integration test is like how organize of body are works together. your testing the

- connection
- the hand shakes
- the data flow between parts of applications

some time you test two connection like user with database sometimes is chain of connections

## End to End Testing

it's mot comprehensive and realistic but also the most complex and expensive
when you run end to end you running real user journey for entire application using actual data.

It is same as real world. these test are slow because it's use :

- real browser automation
- network requests
- database operation
- external service call

## Testing Knowledge

it's about how much you know about the internal working of the system.
it's not only help about what test to write it's also help to predicted how bugs
you could catch.

## Black Box Testing

is about being customer using production without knowing about how it's made they only care that
it do what is suppose to do. it's only focus on input and output. like clicking add add to card that incess the
list of items.

It is valuable for

- Long-term maintenance
- Tracking the system

when testing without understanding code you find

- Confusing error messages
- Unexpected behavior
- Missing features

but you can't test console error , or putting code in input and stuff like that

## White Box Testing

now you have full Knowledge on

- Internal structure
- Logic
- Implementation of code

it's like engineer check that thing that they build. this test do

- Exercise specific code paths
- Test particular algorithms
- Verify that internal logic

you check what happen if user do something wrong or checking the edge cases.
because you know the logic you can write test that

- Hit every branch
- Test every condition
- Verify that each piece of code works as intended

it's valuable for testing

- Algorithms
- Data structures
- complex business logic

the challenge is that can tidy with Implementation because you test

- Internal methods
- Private functions
- Specific code paths

by refactoring you might just break some places even the external behavior be the same

it's mostly used for

- Mathematical calculations
- Data processing algorithms
- Security functions
- Core business logic

the things that often change

## Gray Box Testing

when you have some Knowledge of internal and external. you know what tool do you use
but still do not mainly focus on logic you check by user perspective while check that work same
as expected. by this you can

- Test the riskiest areas
- Use realistic test data
- Cover edge code paths

## Testing by purpose

Testing by purpose refers to categorizing software testing based on its specific goal or intent, such as ensuring correctness, reliability, performance, or security. Examples include functional testing (to verify features work as specified), regression testing (to ensure new changes donâ€™t break existing functionality), and usability testing (to evaluate user experience).

## Functional Testing

function do based on requirements e.g when user search for product dose product appear.
also functional has multiply parts like

### smoke testing

like turn one car and make sure the engin is start the lights work and the basic system operational
this are quick and high level tests that verify most basic functionality.
The first test after deploying the code

### sanity testing

it's more focused like checking specific system work like air conditioning still work after you make
some changes. sanity check the area you modify it's still do task correctly.
this test help to **catch regressions**

### regressions testing

the most important part of the functional testing . this test check that the new code do not break the previous
code accordantly. The challenge it become time consuming as the application growths.

### User Acceptance Testing (UAT)

the final validation before release this test not by

- Developers
- QA engineers
- Product team

it's show error and technical often forgot things like

- COnfusing workflows
- Missing features
- Performance problems
- Integration issues

## Non-Functional Testing

User not care it's works the user care more on :

- work well
- quickly
- securely
- reliably

### Performance Testing

this bing and contain several categories: 

#### Performance Testing: Load testing

by this you check that platform can work on multiply user use it.

#### Performance Testing : Stress testing

gradually ingress the system until it crash you find the limits and how system behave on extreme condition
help to plan for traffic 

#### Performance Testing Volume testing

focus especially or large amount of data. how application works when database contain minions of data. The search remain 
fast 

### Security Testing 

this test include to checking 

- Auth systems
- Validating input handling
- Verify data encryption
- Common vulnerabilities

### Usability testing

it's check how easy and pleasant you application is to use this include testing:

- Navigation & info architecture
- Evaluating form design 
- Error handling 
- Checking accessibility 
- Verify that the app works 

### Compatibility Testing

It's make sure the application is working correctly across different enticements.

## Testing by Execution 

it's about How and When the test actually run. are you run manually when you fill like it or 
you have Automated system the run every step of the system

### Manual Testing 

It's like Monkey see Monkey do. Sometimes need human things like bad UI can't catch by 
test it can get by user. it's like exploration also it's often called **Exploratory Testing**.

### Usability Testing 

Instead of you testing app somebody else test and you watch along side of them. by this you 

- Noticing where people hesitate 
- What confuses them
- How they completely ignore 

The cons are 
- Manual testing takes time 
- Doesn't scale well 
- People miss things 

you have balance between automate and manual 

## Automated Testing 

this when you handed the software tools that run test for you. the best part this 

- Speed 
- Consistency
- Scales like crazy 

it's like saver for regression testing 

## Testing Strategies 

the problems is you don't know 
- What to test 
- How much to test 
- When to test

the problem is that you sometimes do not test some cases you over test some places and 
worse is get falsy truthy which is green while is not testing the right thing this 
are pattern that helps that stop these.

- Testing Trophy 
- Honeycomb Strategy
- Ice Cream Cone Anti-Pattern 
- Testing Diamond 
- Testing Pyramid

## Testing Pyramid 

> Different types of tests have vastly different costs and benefits 

[testing pyramid]('./images/testing_pyramid.png');

during developments you make some changes like : 

- Refactor code 
- Add feature 
- Fix bug 
- Update dependencies

It's for apps like 
- Finance 
- Science 
- Complex algorithms

## Ice Cream Cone Anti-Pattern

[Ice Cream Cone Anti-Pattern]('./images/ice_cream_pattern.png');

This is the opposite  of testing pyramid 
also have some negative things like : 

- Feedback becomes painfully slow
- Debugging becomes a nightmare 
- Maintenance get out of hand

## Testing Trophy 

[Ice Cream Cone Anti-Pattern]('./images/testing_trophy.png');


This is looks familiar to pyramid but with some difference

## Honeycomb Strategy 

[Honeycomb Strategy]('./images/honeycomb_strategy.png');

build separate testing strategy for each part of application.

here is the example 

[Honeycomb example]('./images/honeycomb_example.png');

> Core idea : test where i matters most

the problems are 

- Service contracts 
- Integration environments 
- Data dependencies 